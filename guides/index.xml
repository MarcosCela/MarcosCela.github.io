<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Guides on Wiki</title><link>https://wiki.mcela.dev/guides/</link><description>Recent content in Guides on Wiki</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 23 Sep 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://wiki.mcela.dev/guides/index.xml" rel="self" type="application/rss+xml"/><item><title>Setting up GO_PROXY for private repositories</title><link>https://wiki.mcela.dev/guides/dev/go-proxy/</link><pubDate>Wed, 23 Sep 2020 00:00:00 +0000</pubDate><guid>https://wiki.mcela.dev/guides/dev/go-proxy/</guid><description>Using GO_PROXY, GONOSUMDB and friends Since go 1.13, we can configure a proxy that will be used to download packages. This can be done via the environment variable GOPROXY. By default, the value isGOPROXY=https://proxy.golang.org,direct. This means that packages will be fetched via the given proxy, and falling back to &amp;ldquo;direct&amp;rdquo; (via git) if the proxy cannot find the package.
This way of downloading files also integrates with a checksum database, by default at sum.</description></item><item><title>~/.ssh/config and you</title><link>https://wiki.mcela.dev/guides/dev/ssh-config/</link><pubDate>Mon, 31 Aug 2020 00:00:00 +0000</pubDate><guid>https://wiki.mcela.dev/guides/dev/ssh-config/</guid><description>What is exactly ~/.ssh/config? It&amp;rsquo;s the place for the user-specific configuration for ssh. Like almost any-other CLI tool, ssh accepts a set of configuration parameters by flags, a global config file, or a user config file.
What is it useful for? You can configure a lot of parameters for your connections. If you usually connect to one or more hosts via SSH, it makes things like selecting the identity key, or using a different host alias a breeze.</description></item><item><title>Example super basic Makefile</title><link>https://wiki.mcela.dev/guides/dev/makefile/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://wiki.mcela.dev/guides/dev/makefile/</guid><description>Example makefile A valid Makefile can be REALLY hard, but can also be REALLY simple. The following minimal Makefile allows for the following logic:
It has a default goal set, &amp;ldquo;help&amp;rdquo;. Invoking &amp;ldquo;make&amp;rdquo; will give you a very basic help output. The help goal prints some nice information about what the makefile does. The image target prints a variable. Be careful if you copy-paste this, Makefile requires tabs and not spaces!</description></item><item><title>Guidelines to build sane Docker images</title><link>https://wiki.mcela.dev/guides/dev/docker-images-guide/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://wiki.mcela.dev/guides/dev/docker-images-guide/</guid><description>Building docker containers is easy, dangerous and can cause death You can build a Docker container with a lot of different ways, some are good, some are bad and others are REALLY bad.
The following document will try to give some basic rules and guidelines on how to build a Docker container that is as light as possible, simple, has valuable metadata, and doesn&amp;rsquo;t contain any unwanted secrets.
Rules These are rules.</description></item><item><title>Setting up a private maven mirror</title><link>https://wiki.mcela.dev/guides/java/maven-private-registry/</link><pubDate>Mon, 04 Mar 2019 00:00:00 +0000</pubDate><guid>https://wiki.mcela.dev/guides/java/maven-private-registry/</guid><description>What is a private Maven mirror? When you download dependencies with maven, you usually do it via maven central, and this might not be the best solution. Having a local copy of the maven repository is specially useful if you continually need to download dependencies:
You avoid going through the internet, this can have a huge impact in the speed at you download dependencies. If you have a CI system that &amp;ldquo;starts from scratch&amp;rdquo; because it uses VM&amp;rsquo;s or containers on demand and always starts from a fresh filesystem, you will need to download dependencies every time.</description></item><item><title>Setting up Kubernetes ApiServer auditing with ELK stack</title><link>https://wiki.mcela.dev/guides/kubernetes/elk-audit/</link><pubDate>Tue, 12 Feb 2019 00:00:00 +0000</pubDate><guid>https://wiki.mcela.dev/guides/kubernetes/elk-audit/</guid><description>What is Kubernetes auditing? Kubernetes auditing provides a set of records or log entries documenting what actions have affected the system. Basically, we have access to every API call, along with some metadata.
This can be really useful:
It provides you with security-relevant data, you can see WHO changed WHAT and WHEN. It can be used to detect bad configurations or possible attacks if your API server is exposed to the internet (if your apiserver shows a large ammount of 401 Unauthorized responses, someone might be trying to access your cluster with invalid credentials).</description></item><item><title>Kubernetes DNS problems in heterogeneous clusters</title><link>https://wiki.mcela.dev/guides/kubernetes/kubernetes-dns-problems-in-heterogeneous-clusters/</link><pubDate>Mon, 04 Feb 2019 00:00:00 +0000</pubDate><guid>https://wiki.mcela.dev/guides/kubernetes/kubernetes-dns-problems-in-heterogeneous-clusters/</guid><description>The symptoms Pods will not correctly perform DNS resolution, seemingly at random. One day everything is fine, the next day everything is on fire. Kube-dns pods show some restarts (2-3) in the last few days, these restarts are correlated to the problems, and indicate a bad restart. This means that SOMETIMES, when the kube-dns pod restarted, it did so in a bad state or configuration. Logs on kube-dns failed containers show an upstream DNS resolver of 127.</description></item></channel></rss>